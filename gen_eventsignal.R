#######
##Event Creation and Signal Object Generation for Each subject:

#Overall strcture: 
  #Get to dir, loop over each subject use ID
  #Single sub data proc: use post VBA results and b
  #Assign them to environment as each ID as an list object that contains Event and Signal object which are compatible with pipeline

#Objectives:
  #Read .mat files and see if we need to restructure that

#Compare performance between readMat and read.mat
if (F) {
start_time <- Sys.time()
R.matlab::readMat(filena)->testmat
#doesn't even work
rmatio::read.mat(filena)->testmat.2 #Use #C which is way more efficient, although it seems like it comes with error message 
#Problem with C complier in Macs 

end_time <- Sys.time()
}
#Let's make sense of the process:
  #1, time bin size; calculated by frequency scaling 
  #2, bandit design matrix? Change and modify it

#This function is used to index the mat file generated by r.matlab; 
#Reconstruction functions:
#Maybe you can try using recon method designated for list or array;
#Following will 
recon.list<-function(mat.raw=NULL){
  mat.better<-sapply(mat.raw, function(x){
    emp<-list()
    drop(x)->x
    for (i in 1:length(x)) {
      rownames(x)[i]->whichone
      emp[[whichone]]<-drop(x[i])
    }
    return(emp)
  })
  names(mat.better)<-names(mat.raw)
  return(mat.better)
}
recon.array<-function(x=NULL) {
  emp<-list()
  for (i in 1:length(x)) {
    rownames(x)[i]->whichone
    if (length(emp[[whichone]][[1]])==1) {
      emp[[whichone]]<-drop(unlist((x[[i]])))
    } else if (ifelse(is.null(dim(x[[i]])[1]),-1,dim(x[[i]])[1]) == 1) {
      emp[[whichone]]<-drop(unlist(x[[i]]))
    } else {emp[[whichone]]<-drop((x[[i]]))}
  }
#names(emp)<-names(x)
return(emp)
}
recon.mat<-function(data.raw=NULL) {
  #do recurisive if class of x is list, if it's array then use 
  if (class(data.raw)=="list") {
    lapply(data.raw, function(x) {
      
    }) 
  } else if (class(data.raw)=="array") {
    data.raw<-recon.array(x=data.raw)
  } else if (!lapply(huy$muX,class) %in% c("list","array")) {}
    
  }
#need a level recon:
recon.mat<-function(mat) {
  drop(mat)->mat
  cla<-as.data.frame(lapply(mat,class))
  colnames(cla)[which(t(cla)=="list")]->listobj
  colnames(cla)[which(t(cla)=="array")]->arrayobj
  lapply(mat[arrayobj],recon.array)->arrayrecon

}

makeeprimestruct<-function(rawtext=file.choose(),
                           rawdf=NULL,
                           breakpointname="BreakProc") {
  if (is.null(rawdf)){
    rawdf<-read.csv(rawtext,stringsAsFactors = F,sep = "\t")
  } 
  wherearethebreaks<-grep(breakpointname,rawdf$Procedure)
  rawdf$blocknum<-NA

  for (i in 1:(length(wherearethebreaks)+1)) {
    print(i)
    if (i==1) {
      rawdf$blocknum[i:wherearethebreaks[i]]<-i
      
    } else if (i==(length(wherearethebreaks)+1)) {
      rawdf$blocknum[wherearethebreaks[i-1]:length(rawdf$Procedure)]<-i
     
    } else {
      rawdf$blocknum[wherearethebreaks[i-1]:wherearethebreaks[i]]<-i}
  }
  df<-rawdf[-wherearethebreaks,]
  df$trailnum<-seq_along(df$Procedure)
  df$trialnum.block<-unsplit(lapply(split(df$blocknum,df$blocknum), seq_along),df$blocknum)
  return(df)
}

sigmatransform<-function(x) {
  (1./(1+exp(x)))->y
  return(y)
}

depthoflist <- function(list,thisdepth=0){
  if(!is.list(list)){
    return(thisdepth)
  }else{
    return(max(unlist(lapply(list,depthoflist,thisdepth=thisdepth+1))))    
  }
}

#End

#bandit specific functions:
ds.bandit<-list(nblock=3, ntrial=300, names.event=c("decision","feedback"),
                duration_feedback.mm=1000,ifkind=c("myst","comp"))

bandit.proc<-function(data.mat=data.mat,design=ds.bandit){
  if (is.null(data.mat)) {stop("NO INPUT")}
  ###########do df structure
  
  #NOTE: ALL THE LOGICAL VARIABLES ARE FALSE FOR ABSENT / TRUE FOR EXIST; 
  
  #C0: Create empty environment to put stuff in so that they don't just float around function space but rather saved
  #Also it'd be easier to grab them in later function or loop; since environments are on search path
  #Also, with the envir2df function, it can be converted to df with identical length! #bsrc::dnpl.envir2df(wking)
  wking<-new.env(parent = emptyenv())
  
  #C1: get myst and comp trials
  checkzx<-lapply(design$ifkind, function(x) {
    logiccheck<-!as.logical(seq_along(data.mat$b$protocol.type))
    logiccheck[grep(x,data.mat$b$protocol.type)]<-TRUE
    logiccheck
  })
  names(checkzx)<-ifkind
  #End 
  
  #C2: Make Choice and feedback sensor
  assign("motor_sign",plyr::mapvalues(as.numeric(data.mat$b$stim.RESP),from = c(7,2,3),to = c("leftindex","rightinfex","rightmiddle"),warn_missing = F),envir = wking)
  assign("hand_reg",plyr::mapvalues(as.numeric(data.mat$b$stim.RESP),from = c(7,2,3),to = c("left","right","right"),warn_missing = F),envir = wking)
  assign("zerort_logical", {as.logical(unlist(data.mat$b$stim.RT)=="0" | unlist(data.mat$b$chosen.stim)=="999")},
         envir = wking)
  assign("choice_logical", {as.logical(zerort.logical | checkzx$comp)}, envir = wking)
  assign("feedback_logical", {as.logical(zerort.logical | checkzx$myst)}, envir = wking)
  #END 
  
  #C3: Make trial number & block number timing variables:
  blocknum<-rep(1:design$nblock,each=(design$ntrial / design$nblock))
  assign("run",blocknum,envir = wking)
  assign("trialbyblock",unsplit(lapply(split(blocknum,blocknum), seq_along),blocknum),envir = wking)
  #Get NA in feedback to nothing;
  drop(data.mat$b$feedback.OnsetTime)->data.mat$b$feedback.OnsetTime
  which(is.na(data.mat$b$feedback.OnsetTime))->napos
  data.mat$b$feedback.OnsetTime[napos]<-(drop(data.mat$b$stim.OnsetTime) + drop(data.mat$b$stim.jitter1))[napos]
  
  glmm<-lapply(split(seq(1:design$ntrial),blocknum), function(x) {
      xrange<-min(x):max(x)
      #time<-data.mat$b$stim.OnsetTime
      return(list(decision_onset=(data.mat$b$stim.OnsetTime[xrange]-data.mat$b$stim.OnsetTime[min(x)]) / 1000,
                  decision_end=(data.mat$b$stim.OnsetTime[xrange]-data.mat$b$stim.OnsetTime[min(x)]+data.mat$b$stim.RT[xrange]) /1000,
                  feedback_onset=(data.mat$b$feedback.OnsetTime[xrange]-data.mat$b$stim.OnsetTime[min(x)]) / 1000,
                  feedback_end=(data.mat$b$feedback.OnsetTime[xrange]-data.mat$b$stim.OnsetTime[min(x)]+design$duration_feedback.mm) /1000#,
                  #trial_onset=data.mat$b$stim.OnsetTime[xrange]-data.mat$b$stim.OnsetTime[min(x)],
                  #trial_end=data.mat$b$stim.OffsetTime[xrange]-data.mat$b$stim.OffsetTime[min(x)]
                  ))
  })
  
 
  tes.en<-new.env(parent = emptyenv())
  assign("lzy",list(),envir = tes.en)
  tes<-lapply(glmm, function(x) {
      # assign("tempx",x,envir = tes.en)
      # lapply(names(x),function(y){
      #   xz<-get("tempx",envir = tes.en)
      #   
      # })
    get("lzy",envir = tes.en)->lzy
    for (y in names(x)) {
      lzy[[y]]<-c(lzy[[y]],x[[y]])
    }
    assign("lzy",lzy,envir = tes.en)
    })
  get("lzy",envir = tes.en)->lzy
  for (i in names(lzy)) {
    assign(i,lzy[[i]],envir = wking)
  }
  
  #Last step, get all the ones from 
  finalist<-list()
  for (nev in design$names.event) { #Loop around 
    objects(envir = wking)[grep(nev,objects(envir = wking))]->whichones
    finalist[[nev]]<-data.frame(
      event=nev,
      onset=get(whichones[grep("onset",whichones)],envir = wking),
      duration=get(whichones[grep("end",whichones)],envir = wking) - get(whichones[grep("onset",whichones)],envir = wking),
      run=wking$run,
      trial=wking$trialbyblock
    )
  }
  
  for (i in 1:length(finalist)) {
    if (i==1) {ktz<-finalist[[i]]} else {
    ktz<-rbind(ktz,finalist[[i]])}
  }
  ktz[ktz$allconcat=="NaN"]<-NA
  #ktz<-na.omit(ktz)
  finalist[["allconcat"]]<-ktz

  vba<-recon.array(data.mat$out$suffStat)
  
  #Additional Variables, create here, used in gird:
  
  vba$value.chosen.diff.sigmoid<-(1./(1+exp(as.numeric(unlist(vba["value.chosen.diff"])))))
  vba$nullres<-as.numeric(wking$choice_logical)
  vba$motor.left<-as.numeric(wking$hand_reg=="left")
  vba$motor.right<-as.numeric(wking$hand_reg=="right")
  
  output<-list(event.list=finalist,output.df=bsrc::dnpl.envir2df(wking),value=vba)
  return(output)
}
#End

#Make single signal as a list:
makesignal.single<-function(output,ename,norm="none",normargu=c("durmax_1","evtmax_1"),valuefrom,modifier=NA,style="subset",nonah=T) {
  jrz<-list()
  jrz[["event"]]<-ename
  jrz[["normalization"]]<-norm
  jrz[normargu]<-TRUE
  
  subelist<-output$event.list$allconcat[which(output$event.list$allconcat$event==ename),]
  value<-output$value[[valuefrom]]
  
  value.df<-data.frame(
    run=subelist$run,
    trial=subelist$trial,
    value=value
  )
  if (!is.na(modifier)) {
    #INVERTING THE LOGICAL STATEMENT SO 1 for valid trials and 0 for non-valid!
    if (nonah) {
    modx<-!output$output.df[modifier] & !is.na(subelist$onset)
    } else { modx<-!output$output.df[modifier]}
    switch (style,
            "multiply" = {value.df$value<-value.df$value * as.numeric(modx)},
            "subset"   = {value.df<-value.df[modx ,]}
    )
    
  }
  jrz[["value"]]<-value.df
  return(jrz)
}

#Make all of them with a grid:
makesignalwithgrid<-function(dsgrid=read.csv(gridpath,stringsAsFactors = FALSE), outputdata=NULL,nona=F, expectedtn=300,add_taskness=F) {
  if (is.null(outputdata)) {stop("NO DATA")}
  allofthem<-new.env(parent = emptyenv())
  dsgrid[dsgrid=="NA"]<-NA
  for (i in 1:length(dsgrid$ename)) {
    print(paste("making...",dsgrid$valuefrom[i],sep=""))
    #could have totally do a do.call and make assignment within single function 
    #but that ONE datainput variable is hard to get by with do.call so......loop is fine
    #Forcing all arguments so it's kinda bad....
    result<-makesignal.single(output = outputdata,
                              ename = dsgrid$ename[i],
                              norm = dsgrid$norm[i],
                              normargu = dsgrid$normargu[i],
                              valuefrom = dsgrid$valuefrom[i],
                              modifier = dsgrid$modifier[i],
                              style = dsgrid$style[i],
                              nonah = nona)
    assign(dsgrid$name[i],result,envir = allofthem)
  }
  
  #change it to list:
  allofthemlist<-as.list(allofthem)
  
  #Taskness varibale:
  if (add_taskness) {
  for (taskname in unique(dsgrid$ename)) {
    
    if (any(is.na(output$event.list[[taskname]]))) {
      tempdf<-output$event.list[[taskname]][which(!is.na(output$event.list[[taskname]]$onset)),]
      tempdf.a<-subset.data.frame(tempdf,select = c("run","trial"))
      tempdf.a$value<-1
      allofthemlist[[paste(taskname,"_evt",sep = "")]] <- list(value=tempdf.a,event=taskname,normalization="none")
    }else {allofthemlist[[paste(taskname,"_evt",sep = "")]] <- list(value=1,event=taskname,normalization="none")}
  }
}
  return(allofthemlist)
  
}

getnuisancefrompipe<-function(id=NULL,
                              cfgfilepath="/Volumes/bek/autopreprocessing_pipeline/bandit_oldPreCMMR.cfg",
) {
  cfg<-readLines(cfgfilepath,n=grep("export",readLines(cfgfilepath))[1]-1)
}




if (F) {
  output<-bandit.proc(data.mat = data.mat,design = ds.bandit)
  final<-makesignalwithgrid(outputdata = output,nona = F)

  test.x<-list(unsingedPE=final$signedPEs,
               DecisionAligned_chosen_diff_sigmoid=final$valueDecisionAligned_chosen_diff_sigmoid,
               decision_evt=final$decision_evt,
               feedback_evt=final$feedback_evt)
  #test.x$pe$add_deriv <- TRUE
  #test.x$ev$add_deriv <- TRUE
  
design.full<-dependlab::build_design_matrix(events = output$event.list$allconcat, 
                                       signals = final,
                                       write_timing_files = c("convolved", "AFNI", "FSL"),
                                       tr=1.0)
}

#Use data.frame"
 #Name, Begining, Ending, alter = name, beg, dura

#directory to nuisances
# 
# con <- dbConnect(odbc(),
#                  Driver = "SQLServer",
#                  Server = "OACDATA4",
#                  Database = "crc",
#                  UID = "chenj20",
#                  PWD = rstudioapi::askForPassword("Database password"),
#                  Port = 1433)









